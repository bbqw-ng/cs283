int build_cmd_buff(char *cmdLine, cmd_buff_t *cmd, command_list_t *cmdList) {
  //Empty Command
  if (cmdLine == NULL || strlen(cmdLine) < 1)  {
    printf(CMD_WARN_NO_CMD);
    return WARN_NO_CMDS;
  }

  //copy the original buff into the command
  strcpy(cmd->_cmd_buffer, cmdLine);

  //Check cmdLine for length violation or violation of # of commands
  for (int i = 0, j = 0; *(cmdLine+i) != '\0'; i++) {
    if (*(cmdLine+i) == PIPE_CHAR) 
      ++j;
    if (j > 7) 
      return ERR_TOO_MANY_COMMANDS;
    if (i > ARG_MAX) 
      return ERR_CMD_OR_ARGS_TOO_BIG;
  }

  const char *delim = PIPE_STRING;
  char *cmdCpy = strdup(cmdLine);
  char *save;

  char *token = strtok_r(cmdCpy, delim, &save);
  //Keep track of the number of total commands (different than args of a cmd)
  int cmdNum = 0;

  //Splits it by the pipe \ //
  while (token != NULL) {
    printf("token: %s\n", token);
    char *trimmed = strdup(rightTrim(leftTrim(token)));
    printf("trimmed: %s\n", trimmed);
    int trimmedOriginalLength = strlen(trimmed);

    bool quoteMode = false;
    char *start = trimmed;
    int argIndex = 0, argCount = 0;

    //parsing the command between pipes ( command 1 | command 2 | command 3 ) each per iteration of while loop
    for (int i = 0; i <= trimmedOriginalLength; i++) { 
      if ( (*(trimmed+i) == ' ' && !quoteMode && i != trimmedOriginalLength)) {
        *(trimmed+i) = '\0';
        //makes sure we don't add any extra spaces
        if (start != trimmed+i) {
          cmd->argv[argIndex++] = strdup(start);
          argCount++;
        }
        start = trimmed+i+1;

      } else if (*(trimmed+i) == '\"' && !quoteMode) {
        quoteMode = true;
        start = trimmed+i+1;

      } else if (*(trimmed+i) == '\"' && quoteMode) {
        quoteMode = false;
        *(trimmed+i) = '\0';
        cmd->argv[argIndex++] = strdup(start);
        start = trimmed+i+1;
      } 
    }

    //Adds the last argument into the argv for the command
    if (*start != '\0') {
      cmd[cmdNum].argv[argIndex++] = strdup(start);
    }

    //null terminating the current string
    cmd[cmdNum].argv[argIndex] = NULL;
    cmd->argc = ++argCount;

    printf("printing cmd Buff inside the build func\n");
    printCmdBuff(cmd);
    printf("-----\n");
  

    cmdList->num = cmdNum;
    cmdList->commands[cmdNum++] = *cmd;

    free(trimmed);
    trimmed = NULL;

    token = strtok_r(NULL, delim, &save);
  }

  //printing cmd for sanity check
  //printCmdBuff(cmd);

  free(cmdCpy);
  cmdCpy = NULL;
  return OK;
}
